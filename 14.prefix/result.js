/**
 * @param {string[]} strs
 * @return {string}
 */


 /* Ну, здесь тупо можно начать перебором, сравнивая по элементу,если не совпадение, то мы заканчиваем перебор и возвращаем ответ */


 /* написал простую реализацию через for цикл, буду тестить сейчас */

 /* тесты прошли, буду сабмитить */

 /* опа, 3-ий тест провалился, получается что у нас не конкретно три элемента, а неизвестное количество, либо больше, либо меньше. Значит стоит перебирать массив strs через map? Не через ,map сейчас подумал будет геммор(хотя еще задумался и понял любым спосом даже for of будет геммор, нужно создавать переменную где будем проверять по-символьно строки) К тому же нужно сделать тест кейс для случая когда в массиве только одна строка*/

 /* хочу попытаться сделать внутри цикла for(let i = 0; i < strs[0].length; i++), цикл for of, вот думаю с чего начать...  */

 /* залип на рилсы в инсте, сейчас продолжу :) */

 /* я в этом цикле же перебираю по первому элементу массива, соответственно мне нужно пройтись по всем кроме первого значит нужно заслайсить массив, сейчас загуглю об этом и попытаюсь реализовать  */

 /* написал условие для брейка и теперь понимаю что мне нужно брейкануть внешний цикл, загуглю как сделать указатель на верхнюю. Загуглил, понял. */

 /* вроде закончил, сейчас буду тестить */

 /* тесты прошли, буду сабмитить */

 /* Все верно :) */

 /* сейчас посмотрю как другие проще сделали :) */

 /* не понял как сделали через substring, сейчас спрошу у гипити про разницу моего и этого кода */

 /* Понял. Я проверяю с начала и постепенно дохожу до конца. А через substring наоборот с конца и укорачиваю до начала. По-большому счету логика плюс минус схожая */
 var longestCommonPrefix = function(strs) {
    let res = "";

    //первая попытка

    // for(let i = 0; i < strs[0].length; i++) {
    //     if(strs[0][i] === strs[1][i] && strs[0][i] === strs[2][i]){
    //         res += strs[0][i];
    //     } else {
    //         break;
    //     }
    // }
    outer: for(let i = 0; i < strs[0].length; i++) {
        let sym = strs[0][i];
        for(let str of strs.slice(1)){
            if(sym !== str[i]){
                break outer;
            }
        }
        res += sym;
    }


    return res;
};