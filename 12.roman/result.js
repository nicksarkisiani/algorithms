/**
 * @param {string} s
 * @return {number}
 */



/* первая мысль - это создать какой-то объект через который мы будем забирать значение по ключу и брать элементы. По логике мы читаем строку по символьно и потом ищем элемент в объекте и прибавляем к какой-то начальной сумме. Что же касается элементов типо 4,9,40 и т.д., то мы должны делать сравнение на каждой итерации, если типа следующий символ на порядок больше предыдущего, то мы его читаем как один и прибавляем соответствующее значение к сумме. В конце когда пройдемся по все элементам вернем эту сумму. Теперь попробую это написать */ 

/* создал объект romanObject расписал там значения как в условии 1,5,10,50,100,500,1000. 4,9,40 и т.д. сейчас подумал что не надо в него добавлять, потому что в условии можно добавить код где мы будем брать следующий символ который больше предыдущего и от большего отнимать меньшее и будем получать соответствующее значение, вроде логично продолжу писать */

/* сейчас пришла идея использовать редюс как мы делали на мок-собесе, загуглил можно ли использовать редюсь на строку - нельзя, нужно конвертировать в массив(стоило догадаться) */

/* Сейчас дошло что нельзя в данном случае использовать редюсь или будет очень геморрно, потому что нам надо как-то получать следующий элемент, поэтому попробую написать обычным циклом */
var romanToInt = function(s) {  
    const romanObject = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000

    }

    // const sArr = s.split("")
    // return sArr.reduce((prev, curr) => {
        
    // }, 0) - холостая попытка :)

    let result = 0;
    for(let i = 0; i < s.length; i++){
        if(i + 1 <= s.length && romanObject[s[i]] < romanObject[s[i + 1]]){
            result += romanObject[s[i+1]]-romanObject[s[i]];
            i++;
            continue;
        }

        result += romanObject[s[i]];
    }
    // закончил писать код, сейчас буду тестить
    return result;
};

// все оказалось верным :)