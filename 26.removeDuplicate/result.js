/**
 * @param {number[]} nums
 * @return {number}
 */


// ссылка на задачу -- https://leetcode.com/problems/remove-duplicates-from-sorted-array/

 /* если я правильно понял это банальное использование set */

 /* я не совсем понял, что нуджно вернуть, то ли массив, где за место дубликатов мы поставим какое-то значение, то ли количество уникальных элементов */

 /* спрошу-ка у джипити с твоим промптом, что надо вернуть... */

 // ааа, массив нужно in-place изменить без использования доп. переменных, то есть мутировать
 // можно тогда в таком случае встроенную функцию сорт использовать, хотя не помню возращает она новый массив или изменяет существующий

// загуглил он изменяет существующий, в таком случае можно им воспользоваться

// хотя туплю нахер нам здесь сорт нужен, мы из массива элементы вычистить хотим, а не сортировать

// спросил у джипити про сет, что нельзя его тут использовать, подсказал про два указателя мне

// бля, ну тогда пошли обычным циклом... 

// написал реализацию как смещать уникальные элементы вначало, теперь надо добавить их удаление или замену...
//можно ведь засплитить массив

// ой, я оказывается return не написал, поэтому и ошибку мне кидало, сейчас написал и даже ничего удалять не пришлось, но сплит хорошая идея

// покажу джипити пусть оценит самый сильный и опытный AI наставник :)

// обкекал меня и сказал что у меня лишные переменные checkValue и changingPosition. Просто дублирование кода

//Я с ним согласен, но все равно зачем-то их использовал...

// Убрал дублирование теперь ругается на то, что массив может быть пустым
var removeDuplicates = function(nums) { 

    if(nums.length === 0) return 0; // -- добавил по совету джипити, хотя в данной задаче излишне

    // let checkValue = nums[0];
    // let changingPosition = 1; -- удалил по совету джипити
    let k = 1;

    for(let i = 1; i < nums.length; i++){

        // if(checkValue !== nums[i]){
        //     checkValue = nums[i];
        //     nums[changingPosition] = nums[i];
        //     changingPosition++;
        //     k++;
        // } -- упрощаю по совету джипити

        if(nums[k-1] !== nums[i]){
            nums[k] = nums[i];
            k++;
        }
    } 

    return k;

};